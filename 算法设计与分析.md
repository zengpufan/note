# 循环不变式
证明循环算法正确的一个方法是通过循环不变式。
循环不变式分为初始，保持和终止三个阶段，就像数学归纳法一样。
# 递归式的求解
递归式的求解有三种方法：
递归树法、代入法、主方法
## 递归树法
递归树法是将递归是画成一个递归树，计算每层的时间复杂度，最后用级数求和将所有的项加到一起。
![](./算法设计与分析/递归树.png)
## 代入法
- 假设T(1)的时间复杂度为O(1)，实际上一般的算法最小问题的时间复杂度都是常数，这个可以不证明。
- 假设T(n)=O(f(n))，猜测递归式的时间复杂度。
- 数学归纳法,假设对k < n,有T(k) ≤ c(f(k)),证明T(n) ≤ c(f(n))，证明前一项正确的情况下，后一项是正确的。

- 下面是一个错误的示例，由于倒数第二个式子并不符合数学归纳法的猜测，故推导是错误的。必须显示地推导出假设的复杂度。
![](./算法设计与分析/截屏2024-11-26%2010.31.33.png)

## 主方法



# 排序算法和中位数
## 堆排序算法
- 堆维护算法
堆维护算法是将两个堆合并成一个，其中，堆顶元素是不符合要求的，两个子堆是符合要求的堆。这个算法的时间复杂度为O(logn)
- 建堆算法
建堆算法，假设有一个长度为n的数组，那么n/2之后的元素都是叶子结点，不需要遍历和维护，但是之前的元素都是非叶子结点，需要调用堆维护算法进行维护。总共需要调用n/2次堆维护算法，这个算法的一个上界是O(nlogn)。但是对于一个有n个元素的堆，每一层的节点个数为n/2^h,每个节点需要比较的次数为h。求级数之和（直接积分）可得算法复杂度为O(n)。（证明时以层为单位）

## 线性时间排序
- 计数排序
找到输入数据的范围（最大值和最小值）。
创建一个计数数组，用于记录每个值出现的次数。
通过累加计数数组，确定每个元素的最终位置。
根据计数数组，将元素放入正确位置。
- 基数排序
基数排序是对计数排序的一次优化，依次按照被排序数的每一位进行排序。
- 桶排序
桶排序是假定数据的分布是随机的，然后将数据划分到若干个桶内，然后进行排序

# 随机算法的复杂度分析
## 指示器变量
指示器变量的定义如下：
I_A(ω) =
1, 如果 ω ∈ A
0, 如果 ω ∉ A

# 二叉搜索树
## 二叉搜索树的插入
二叉搜索树在插入时，直接将元素插入到树的叶子结点上即可。
## 二叉搜索树的删除
- 如果节点是叶子节点，直接删除。
- 如果节点有一个子节点，用这个子节点替换被删除的结点。
- 如果节点有两个子节点，用中序后继或前驱替换，并递归删除替代节点。
# 红黑树
## 红黑树要满足的性质
- 节点是红色或黑色
每个节点要么是红色，要么是黑色。
- 根节点和叶节点是黑色
红黑树的根节点和叶节点始终是黑色的。
- 红色节点的子节点必须是黑色（不允许连续的红色节点）
即红色节点不能有红色的父节点或子节点，称为“红色节点的子节点为黑色”的性质。
- 从任一节点到其所有叶子节点的每条路径上必须包含相同数量的黑色节点
叶子节点（空节点）是隐式的黑色节点。路径上的黑色节点数称为黑高（Black Height）。

## 红黑树的插入操作
红黑树插入的结点是红色结点，并且插入到树的最底层。除非红黑树是空的，这是插入到跟节点，并且插入的是黑色结点。
- case1: 父节点是黑色，那么插入之后整棵树依旧满足红黑树的性质，不需要进行额外的调整。
- case2: 如果父节点是红色，这时需要进行额外的调整（这时祖父结点一定是黑色）。
- - case2.1: 如果叔结点是红色，那么将祖父结点的黑色向下传递，即叔结点和父节点染成黑色，祖父结点染成红色。这时检查祖父结点是否符合要求，如不符合，递归的进行调整。
- - case2.2: 如果叔结点是黑色的，需要进行旋转。旋转分为四种，分别是LL、LR、RL、RR。这几种类别分别对应父节点和插入结点这两个结点相对于祖父结点的位置。对于LR和RL情况，通过旋转父节点和插入结点转换为LL和RR情况（将红色结点旋转到一条线上）。对于RR和LL情况，通过旋转祖父结点和父节点达到调整的目的。这时，新的祖父结点（原父节点）可能依旧不满足红红的限制，但是黑高是相等的，需要继续进行递归调整。

## 红黑树的删除操作

# 高级数据结构

# 动态规划
动态规划是一种表格方法，将子问题的最优解存到表格中，来避免重复的计算。动态规划分为递归的写法（带备忘录的自顶向下方法）和迭代的写法（自底向上方法）。
## 动态规划的设计方法
- 刻画一个最优解的结构特征
- 递归地定义最优解的值
- 计算最优解的值，通常采用自底向上的方法
- 利用计算出的信息构造一个最优解

## 动态规划的性质
- 最优子结构性质：问题的最优解是由子问题的最优解组合而成。（最短路径问题的子问题还是最短路径，是具有最优子结构的。但是最长路径并非如此）
- 子问题是无关且重叠的：重叠的意思是子问题需要多次计算，但是子问题的解之间互不影响。（例如最短路径的子问题是互补影响的，但是最长路径子问题是相互影响的）

- 最优子结构的证明方法：剪切粘贴法。剪切粘贴法就是假定子问题的解不是最优解，将这个子问题的解带入，可以得到一个更优的解。

## 动态规划的子问题图
上文中提到，动态规划是一种表格法，将所有问题的最优解放到表格中。基于此，我们可以将表格转换为一个问题转换图，大问题的解是由小的问题转换而来。因此，可以得出，动态规划的时间复杂度是问题图的结点数和边数。

# 贪心算法
贪心算法是一种特殊的动态规划，能使用贪心算法解决的问题都能使用动态规划解决。
因此，动态规划问题所具有的性质，贪心问题也都具有。
但是，贪心问题与动态规划的区别在于，贪心问题在使用小问题的解推导大问题的解有一个直接而正确的选择。

## 拟阵
拟阵（Matroid）是一种抽象的数学结构，用来统一地研究“独立性”这一概念。在贪心问题中，拟阵用来证明一个问题是否具有最优子结构。
  
一个拟阵由两部分组成：
一个底集E，可以是任意一组对象，比如向量、图的边等。一个由 E 的子集组成的集合 I，这些子集被称为独立集。在贪心问题中，E就是所有最小的子问题的集合，I就是所有由子问题组成的问题。
  
独立集需要满足以下三个条件：
非空性： 最起码，空集（什么都不包含的集合）是独立集。
遗传性： 如果一个集合是独立集，那么从它里面取出一些元素后得到的集合，仍然是独立集。（简单来说，大集合独立，小集合也独立。）
交换性： 如果有两个独立集，其中一个比另一个大（元素更多），那么从大的集合里取一个元素，加到小的集合里，新的集合仍然是独立集。（大的独立集可以“扩展”小的独立集。）


加权和加权胚：我们对E上的每一个元素加上一个权重w，那么这时计算整个胚的权重，得到的就是加权胚。

- 拟阵的胚是拟阵中的最大独立子集


# 摊还分析

- 聚合分析
- 核算法
- 势能法

# 斐波那契堆
斐波那契堆不是一个单一的树，而是一组松散的堆序树（树的根节点比子节点小）。
所有的堆序树的根节点以一个根链表的形式组织起来。
 
1. 插入元素（O(1) 摊还时间）
把新元素作为一个单节点树，直接加到根链表里。
不需要立即整理堆，省时省力。
2. 合并堆（O(1) 摊还时间）
将两个堆的根链表简单地合并到一起。
这是斐波那契堆最大的优点之一，传统堆（如二叉堆）需要复杂的操作来合并。
3. 删除最小值（O(logn) 摊还时间）
找到当前堆中最小的根节点。
将其子节点逐一添加到根链表中。
对根链表进行“整理”，即合并具有相同阶数的树（类似于“配对”相同大小的斐波那契树）。
4. 减少键值（O(1) 摊还时间）
如果某个节点的值减少到比父节点还小，就切断该节点及其子树，并把它放到根链表中。
如果某个节点被切断多次，可能触发更高层的切断，直到树满足平衡条件。
5. 删除节点（O(logn) 摊还时间）
先用减少键值操作将目标节点减到负无穷（比最小值还小）。
然后执行删除最小值操作。


